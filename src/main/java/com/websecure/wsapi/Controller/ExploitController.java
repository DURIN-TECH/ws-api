package com.websecure.wsapi.Controller;

import com.websecure.wsapi.Document.Dapp;
import com.websecure.wsapi.Document.Exploit;
import com.websecure.wsapi.Error.ResourceNotFoundException;
import com.websecure.wsapi.Repository.DappRepository;
import com.websecure.wsapi.Repository.ExploitRepository;
import com.websecure.wsapi.Response.ErrorResponse;
import com.websecure.wsapi.Response.SuccessResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RequestMapping("/api/exploits")
@RestController
public class ExploitController {
    @Autowired
    ExploitRepository exploitRepository;

    @Autowired
    DappRepository dappRepository;

    private final Logger LOGGER = LoggerFactory.getLogger(ExploitController.class);

    @GetMapping()
    public ResponseEntity<Object> getExploits(){
        LOGGER.info("Fetch All Exploits Zone");
        return new ResponseEntity<>(new SuccessResponse(exploitRepository.findAll()), HttpStatus.OK);
    }

    @GetMapping("/{name}")
    public ResponseEntity<Object> getExploits(@PathVariable String name){
        Dapp dapp = dappRepository.findDappByNameIgnoreCase(name)
                                .orElseThrow(() -> new ResourceNotFoundException("No dapp with the name: " + name + " found"));
        List<Exploit> exploits = exploitRepository.findExploitsByDappId(dapp.getId());
        return new ResponseEntity<>(new SuccessResponse(exploits), HttpStatus.OK);
    }

    @PostMapping("/{name}")
    private ResponseEntity<Object> addExploit(@PathVariable String name, @RequestBody Exploit exploit){
        LOGGER.info("Saving Exploits into Database Zone");
        Dapp dapp = dappRepository.findDappByNameIgnoreCase(name).
                orElseThrow(() -> new ResourceNotFoundException("Can't find dapp " + name));
        exploit.setDappId(dapp.getId());
        exploitRepository.save(exploit);
        return new ResponseEntity<>(new SuccessResponse(exploit), HttpStatus.CREATED);
    }
    
     @DeleteMapping("/{id}")
    public ResponseEntity<Object> deleteExploit (@PathVariable("id") String id) {
         LOGGER.info("Delete Exploits Zone");
         Exploit exploit = exploitRepository.findById(id)
                 .orElse(null);

         if (exploit != null) {
             exploitRepository.delete(exploit);
             Map<String, Boolean> response = new HashMap<>();
             response.put("deleted", Boolean.TRUE);
             return ResponseEntity.ok(new SuccessResponse(response));
         }
         return new ResponseEntity<>(new ErrorResponse(
                 new ResourceNotFoundException("No exist with id :" + id).getMessage()), HttpStatus.NOT_FOUND);
    }

    @PutMapping()
    public ResponseEntity<Object> updateExploit(@RequestBody Exploit exploit){
        Exploit savedExploit = exploitRepository.findById(exploit.getId()).
                                orElse(null);

        if (savedExploit != null) {
            savedExploit.setDappId(exploit.getDappId());
            savedExploit.setDate(exploit.getDate());
            savedExploit.setAudited(exploit.getAudited());
            savedExploit.setAmountLost(exploit.getAmountLost());

            return new ResponseEntity<>(new SuccessResponse(exploitRepository.save(savedExploit)), HttpStatus.NO_CONTENT);
        }
        return new ResponseEntity<>(
                new ErrorResponse(
                        new ResourceNotFoundException("No exploit with the id: " + exploit.getId() + " found").getMessage()), HttpStatus.NOT_FOUND);
    }
}
